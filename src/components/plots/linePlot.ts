///<reference path="../../reference.ts" />

module Plottable {
  export module Plots {
    export class Line<X> extends XYPlot<X, number> {

      /**
       * A Line Plot draws line segments starting from the first data point to the next.
       *
       * @constructor
       */
      constructor() {
        super();
        this.addClass("line-plot");
        var animator = new Animators.Easing();
        animator.stepDuration(Plot._ANIMATION_MAX_DURATION);
        animator.easingMode("exp-in-out");
        animator.maxTotalDuration(Plot._ANIMATION_MAX_DURATION);
        this.animator(Plots.Animator.MAIN, animator);
        this.attr("stroke", new Scales.Color().range()[0]);
        this.attr("stroke-width", "2px");
      }

      protected _createDrawer(dataset: Dataset): Drawer {
        return new Plottable.Drawers.Line(dataset);
      }

      protected _getResetYFunction() {
        // gets the y-value generator for the animation start point
        var yDomain = this.y().scale.domain();
        var domainMax = Math.max(yDomain[0], yDomain[1]);
        var domainMin = Math.min(yDomain[0], yDomain[1]);
        // start from zero, or the closest domain value to zero
        // avoids lines zooming on from offscreen.
        var startValue = (domainMax < 0 && domainMax) || (domainMin > 0 && domainMin) || 0;
        var scaledStartValue = this.y().scale.scale(startValue);
        return (d: any, i: number, dataset: Dataset) => scaledStartValue;
      }

      protected _generateDrawSteps(): Drawers.DrawStep[] {
        var drawSteps: Drawers.DrawStep[] = [];
        if (this._animateOnNextRender()) {
          var attrToProjector = this._generateAttrToProjector();
          attrToProjector["d"] = this._constructLineProjector(Plot._scaledAccessor(this.x()), this._getResetYFunction());
          drawSteps.push({attrToProjector: attrToProjector, animator: this._getAnimator(Plots.Animator.RESET)});
        }

        drawSteps.push({attrToProjector: this._generateAttrToProjector(), animator: this._getAnimator(Plots.Animator.MAIN)});

        return drawSteps;
      }

      protected _generateAttrToProjector() {
        var attrToProjector = super._generateAttrToProjector();
        Object.keys(attrToProjector).forEach((attribute: string) => {
          if (attribute === "d") { return; }
          var projector = attrToProjector[attribute];
          attrToProjector[attribute] = (data: any[], i: number, dataset: Dataset) =>
            data.length > 0 ? projector(data[0], i, dataset) : null;
        });

        return attrToProjector;
      }

      /**
       * Returns the PlotEntity nearest to the query point by X then by Y, or undefined if no PlotEntity can be found.
       *
       * @param {Point} queryPoint
       * @returns {PlotEntity} The nearest PlotEntity, or undefined if no PlotEntity can be found.
       */
      public entityNearest(queryPoint: Point): PlotEntity {
        var minXDist = Infinity;
        var minYDist = Infinity;
        var closest: PlotEntity;
        this.entities().forEach((entity) => {
          if (!this._visibleOnPlot(entity.datum, entity.position, entity.selection)) {
            return;
          }
          var xDist = Math.abs(queryPoint.x - entity.position.x);
          var yDist = Math.abs(queryPoint.y - entity.position.y);

          if (xDist < minXDist || xDist === minXDist && yDist < minYDist) {
            closest = entity;
            minXDist = xDist;
            minYDist = yDist;
          }
        });

        return closest;
      }

      protected _propertyProjectors(): AttributeToProjector {
        var propertyToProjectors = super._propertyProjectors();
        propertyToProjectors["d"] = this._constructLineProjector(Plot._scaledAccessor(this.x()), Plot._scaledAccessor(this.y()));
        return propertyToProjectors;
      }

      protected _constructLineProjector(xProjector: Projector, yProjector: Projector) {
        var definedProjector = (d: any, i: number, dataset: Dataset) => {
          var positionX = Plot._scaledAccessor(this.x())(d, i, dataset);
          var positionY = Plot._scaledAccessor(this.y())(d, i, dataset);
          return positionX != null && !Utils.Math.isNaN(positionX) &&
                 positionY != null && !Utils.Math.isNaN(positionY);
        };
        return (datum: any, index: number, dataset: Dataset) => {
          return d3.svg.line()
                       .x((innerDatum, innerIndex) => xProjector(innerDatum, innerIndex, dataset))
                       .y((innerDatum, innerIndex) => yProjector(innerDatum, innerIndex, dataset))
                       .defined((innerDatum, innerIndex) => definedProjector(innerDatum, innerIndex, dataset))(datum);
        };
      }

      protected _getDataToDraw() {
        var dataToDraw = new Utils.Map<Dataset, any[]> ();
        this.datasets().forEach((dataset) => dataToDraw.set(dataset, [dataset.data()]));
        return dataToDraw;
      }
    }
  }
}
